#!/public/home/liujf/software/program/R-4.3.1-no-dev/bin/Rscript

########################################################################################################################
## Version: 1.3.0
## Author:    Liweining liwn@cau.edu.cn
## Orcid:     0000-0002-0578-3812
## Institute: College of Animal Science and Technology, China Agricul-tural University, Haidian, 100193, Beijing, China
## Date:      2024-08-20
##
## Functionï¼š
## Calculate the LD degree of SNPs within the block
##
##
## Usage: ./block_LD_cor.R --ldList "/path/to/plink/ld/files/" ...(Please refer to --help for detailed parameters)
##
## License:
##  This script is licensed under the GPL-3.0 License.
##  See https://www.gnu.org/licenses/gpl-3.0.en.html for details.
########################################################################################################################


# Load required packages
cat("Loading required packages... \n\n")
suppressPackageStartupMessages(library("data.table"))
suppressPackageStartupMessages(library("dplyr"))
suppressPackageStartupMessages(library("getopt"))
suppressPackageStartupMessages(library("ggplot2"))
suppressPackageStartupMessages(library("Cairo"))

## Command-line arguments
spec <- matrix(
  c(
    "ldList", "I", 1, "character", "[Required] GWAS results file[s] generated by Plink",
    "chr",    "C", 1, "double",    "[Optional] chromosome/NULL",
    "win",    "W", 1, "double",    "[Optional] windows kb/50",
    "slid",   "S", 1, "double",    "[Optional] slide kb/25",
    "max",    "M", 1, "double",    "[Optional] max distance kb/",
    "seg",    "E", 1, "double",    "[Optional] Criteria for interval consolidation /25",
    "out",    "O", 1, "character", "[Optional] output file name prefix/NULL",
    "dir",    "D", 1, "character", "[Optional] working directory/NULL",
    "sumO",   "s", 0, "logical",   "[Optional] Output data for drawing",
    "help",   "h", 0, "logical",   "This is Help!"
  ),
  byrow = TRUE, ncol = 5
)
opt <- getopt(spec = spec)

## Check parameters
if (!is.null(opt$help) || is.null(opt$ldList)) {
  cat(paste(getopt(spec = spec, usage = TRUE), "\n"))
  quit()
}

## File name prefixes
prefixs <- unlist(strsplit(opt$ldList, " "))

## Default parameters
if (is.null(opt$win)) opt$win <- 50
if (is.null(opt$slid)) opt$slid <- 25
if (is.null(opt$seg)) opt$seg <- 0.1
if (is.null(opt$out)) opt$out <- paste(prefixs, collapse = "_")

## Working directory
if (!is.null(opt$dir)) setwd(opt$dir)

## File names
files <- paste0(prefixs, ".ld")

## Number of populations
npop <- length(files)

## Read Plink's LD results
cat("Reading and merging results...\n")
for (i in 1:npop) {
  ## Check if the file exists
  if (!file.exists(files[i])) {
    cat("file: ", files[i], "not found.\n")
    quit()
  }

  ## Read the file (Plink generated .ld file without a header row)
  ldi <- fread(files[i], select = c(2, 5, 7))
  names(ldi) <- c("BP_A", "BP_B", prefixs[i])

  if (i == 1) {
    results <- ldi

    ## Exclude SNP pairs with distances greater than the set value
    results$dist <- abs(results$BP_A - results$BP_B) / 1000 # kb
    # results <- results[!results$dist > opt$max, ]
  } else {
    results <- inner_join(results, ldi, by = c("BP_A", "BP_B"))
  }
}

cat("LD results loaded.\n")
## Mark physical positions
pos <- unique(results$BP_A)
pos <- pos[order(pos)]

## Number of regions
win_num <- (length(pos) - opt$win) %/% opt$slid + 1
cor_win <- data.frame(win = 1:win_num, cor = NA, star = NA, end = NA, dist = NA)

## Calculate LD consistency within regions
for (j in 1:win_num) {
  cor_win$star[j] <- (j - 1) * opt$slid
  cor_win$end[j] <- (j - 1) * opt$slid + opt$win
  win_pos <- pos[cor_win$star[j]:cor_win$end[j]]
  cor_win$dist[j] <- as.character(round(mean(win_pos) / 1000000, 1))
  index_winj <- results$BP_A %in% win_pos & results$BP_A %in% win_pos
  cor_win$cor[j] <- cor(results[index_winj, 3], results[index_winj, 5])
}

## Sorting x-axis labels
cor_win$dist <- factor(cor_win$dist, levels = unique(cor_win$dist))

## Output interval for x-axis labels
every_nth <- function(n) {
  return(function(x) {
    x[c(TRUE, rep(FALSE, n - 1))]
  })
}

## Plotting
title <- paste0("chr", opt$chr, "_windows", opt$win, "_slide", opt$slid)
CairoPNG(paste0(opt$out, "_", title, ".png"), width = 1000, height = 600, bg = "white")

ggplot(cor_win, aes(x = dist, y = cor)) +
  geom_bar(position = position_dodge(), stat = "identity", width = 0.8) +
  theme(
    axis.text.x = element_text(colour = "black", size = 14, angle = 60, hjust = 0.9),
    axis.text.y = element_text(size = 14, face = "plain"),
    axis.title.x = element_text(size = 14, face = "plain"),
    axis.title.y = element_text(size = 14, face = "plain"),
    legend.text = element_text(size = 20),
    legend.position = "bottom",
    legend.title = element_blank(),
    panel.border = element_blank(),
    axis.line = element_line(colour = "black", linewidth = 0.9),
    panel.background = element_blank(),
    panel.grid.major = element_blank(),
    panel.grid.minor = element_blank()
  ) +
  geom_hline(aes(yintercept = 1.0), linetype = "dashed") +
  geom_hline(aes(yintercept = mean(cor)), colour = "#990000", linetype = "dashed") +
  labs(
    title = "Local LD consistency of breed A and B", x = "Distance (Mbp)",
    y = "Correlation of LD phase", size = 16
  ) +
  theme(plot.title = element_text(hjust = 0.5)) +
  scale_x_discrete(breaks = every_nth(n = 2)) +
  scale_y_continuous(expand = c(0.001, 0.005))

dev.off()

## Output plotting data
if (!is.null(opt$sumO)) {
  write.table(cor_win, paste0(opt$out, "_", title, ".txt"), row.names = FALSE, quote = FALSE)
}

## Consolidate adjacent windows based on certain thresholds
i <- 1
new_region <- 0
while (i < win_num) {
  s <- i
  e <- i
  hit <- FALSE

  while (!hit && i < win_num) {
    diff <- abs(cor_win$cor[i] - cor_win$cor[i + 1]) >= opt$seg
    if (diff) {
      e <- i
      hit <- TRUE
    }
    i <- i + 1
  }
  new_region <- c(new_region, cor_win$end[e] - 25)
}

## Recalculate correlation coefficients
cor_win_n <- data.frame(win = new_region, cor = NA, star = NA, end = NA)
cor_win_n <- cor_win_n[!(cor_win_n$win < opt$win & cor_win_n$win != 0), ]

for (j in 1:(nrow(cor_win_n) - 1)) {
  # cat('j=', j, '\n')
  cor_win_n$star[j] <- cor_win_n$win[j]
  cor_win_n$end[j] <- cor_win_n$win[j + 1]
  win_pos <- pos[cor_win_n$star[j]:cor_win_n$end[j]]
  index_winj <- results$BP_A %in% win_pos & results$BP_A %in% win_pos

  cor_win_n$cor[j] <- cor(results[index_winj, 3], results[index_winj, 5])
}
cor_win_n <- cor_win_n[!is.na(cor_win_n$cor), ]
cor_win_n$nSNP <- as.character(cor_win_n$end - cor_win_n$star)

## Plotting
title <- paste0("chr", opt$chr, "_new_region")
CairoPNG(paste0(opt$out, "_", title, "_combine.png"),
  width = 1000, height = 600,
  bg = "white"
)

barplot(cor_win_n$cor,
  names.arg = cor_win_n$nSNP, ylim = c(0, 1),
  main = "Local LD consistency of breed A and B",
  xlab = "Number of SNP", ylab = "Correlation of LD phase",
  cex.axis = 1.5, cex.lab = 1.5, cex.names = 1.2
)
abline(h = 1, col = "lightgray", lty = 3)
abline(h = mean(cor_win_n$cor), col = "red", lty = 3)

# ggplot(cor_win_n, aes(x = nSNP, y = cor))+
#   geom_bar(position=position_dodge(), stat="identity", width = 0.9)+
#   theme(axis.text.x=element_text(colour="black",size=14, angle = 60,hjust = 0.9),
#         axis.text.y=element_text(size=14,face="plain"),
#         axis.title.x=element_text(size=14,face="plain"),
#         axis.title.y=element_text(size=14,face="plain"),
#         legend.text=element_text(size=20),
#         legend.position="bottom",
#         legend.title=element_blank(),
#         panel.border = element_blank(),
#         axis.line = element_line(colour = "black",linewidth = 0.9),
#         panel.background = element_blank(),
#         panel.grid.major = element_blank(),
#         panel.grid.minor = element_blank())+
#   geom_hline(aes(yintercept = 1.0), linetype="dashed")+
#   geom_hline(aes(yintercept = mean(cor)), colour="#990000", linetype="dashed")+
#   labs(title = "Local LD consistency of breed A and B", x = "Number of SNP",
#        y = "Correlation of LD phase", size = 16)+
#   theme(plot.title = element_text(hjust = 0.5))+
#   scale_x_discrete(breaks = every_nth(n = 1))+
#   scale_y_continuous(expand = c(0.001, 0.005))

dev.off()
