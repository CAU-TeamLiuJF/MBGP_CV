#!/public/home/liujf/software/program/R-4.3.1-no-dev/bin/Rscript

########################################################################################################################
## Version: 1.3.0
## Author:    Liweining liwn@jaas.ac.cn
## Orcid:     0000-0002-0578-3812
## Institute: College of Animal Science and Technology, China Agricul-tural University, Haidian, 100193, Beijing, China
## Date:      2024-08-20
##
## Function：
## Divide the genome into blocks based on the physical location of SNPs, gene frequencies and LD between breeds
##
##
## Usage: ./fix_frq_ld_bolck.R --prefixs "/path/to/LD/result/files" ...(Please refer to --help for detailed parameters)
##
## License:
##  This script is licensed under the GPL-3.0 License.
##  See https://www.gnu.org/licenses/gpl-3.0.en.html for details.
########################################################################################################################

## Load packages
cat("Loading required packages... \n")
suppressPackageStartupMessages(library("data.table"))
suppressPackageStartupMessages(library("dplyr"))
suppressPackageStartupMessages(library("getopt"))

## Command-line parameters
spec <- matrix(
  c("prefixs",   "I", 1, "character", "[Required] LD results file[s] generated by Plink",
    "map",       "m", 1, "character", "[Required] map/bim file of plink/NULL",
    "win",       "W", 1, "integer",   "[Optional] number of SNP in each region before merge/100",
    "bin_merge", "M", 1, "character", "[Optional] fix/ld/frq",
    "seg",       "E", 1, "double",    "[Optional] Criteria for interval consolidation/0.1",
    "out",       "O", 1, "character", "[Optional] output file name prefix/NULL",
    "dir",       "D", 1, "character", "[Optional] working directory/NULL",
    "help",      "h", 0, "logical",   "This is Help!"),
  byrow = TRUE, ncol = 5)
opt <- getopt(spec = spec)

## Check parameters
if (!is.null(opt$help) || (is.null(opt$prefixs) && (is.null(opt$map) && opt$bin_merge == "fix"))) {
  cat(paste(getopt(spec = spec, usage = TRUE), "\n"))
  quit()
}

## Working directory
if (!is.null(opt$dir)) setwd(opt$dir)

## Hide summarise prompts
options(dplyr.summarise.inform = FALSE)

## map file
map <- read.table(opt$map)
names(map)[1:4] <- c("CHR", "SNP", "cM", "POS")

## Number of SNP
snp_total <- nrow(map)

## Default parameters
if (is.null(opt$bin_merge)) opt$bin_merge <- "ld"
if (is.null(opt$win)) opt$win <- 100
# if (is.null(opt$slid)) opt$slid <- 25
if (is.null(opt$seg)) opt$seg <- 0.1
if (is.null(opt$out)) opt$out  <- paste(c(opt$prefixs, "merge_bins.txt"), collapse = "_")

## If win=1, one block is output, including all the marks
if (opt$win == 1) {
  bin_cor <- data.frame(chr = NA, bins = 1, nsnp = snp_total, pos_start = NA, pos_end = NA, data_cor = NA)
  write.table(bin_cor, opt$out, col.names = FALSE, row.names = FALSE)
  bin_cor <- data.frame(nsnp = snp_total)

  write.table(bin_cor, opt$out, col.names = FALSE, row.names = FALSE)
  cat("file with only one region has been outputed.\n")
  quit()
}

## Chromosome number
chrs <- unique(map$CHR)

## Output regions with fixed SNP numbers
if (opt$bin_merge == "fix") {
  nsnp_bin <- NULL
  for (i in seq_along(chrs)){
    nsnp_i <- sum(map$CHR == chrs[i])
    win_num <- floor(nsnp_i / opt$win)
    if (win_num < 1) win_num <- 1
    nsnp_bini <- rep(opt$win, win_num)
    nsnp_bini[win_num] <- nsnp_bini[win_num] + nsnp_i - sum(nsnp_bini)
    nsnp_bin <- c(nsnp_bin, nsnp_bini)
  }

  ## Check if the number of SNPs is the same as in the map file
  if (snp_total != sum(nsnp_bin)) {
    cat("Error! The number of snps in bins file is inconsistent with the map file.\n")
    cat("bins=", sum(nsnp_bin), "≠", "map=", snp_total, "\n")
    quit(status = 1)
  }

  ## Output to block file
  write.table(nsnp_bin, opt$out, col.names = FALSE, row.names = FALSE)
  cat("Number of fixed bins: ", length(nsnp_bin), "\n")
  cat("File contain fixed number of snps in bins has been output to: ", opt$out, "\n")
  quit()
}

## File name
prefixs <- unlist(strsplit(opt$prefixs, " "))
if (opt$bin_merge == "ld") {
  files <- paste0(prefixs, ".ld") 
} else if (opt$bin_merge == "frq") {
  files <- paste0(prefixs, ".frq")
} else {
  cat("bin_merge can only be frq/ld.\n")
  quit()
}

## Check if files exist
if (!file.exists(files[1])) {
  cat(files[1], "not found!\n")
  quit()
} else if (!file.exists(files[2])) {
  cat(files[2], "not found!\n")
  quit()
}

## Read plink's ld results
cat("Reading files from plink...\n")
data1 <- fread(files[1])
data2 <- fread(files[2])
cat("results loaded.\n")

## File type (ld/frq file)
if (opt$bin_merge == "ld") {
  names(data1)[1] <- names(data2)[1] <- "CHR"
  data12 <- inner_join(data1, data2, by = c("CHR", "BP_A", "BP_B"), suffix = c("_1", "_2"))

  ## Distance between marker pairs
  data12$dist <- abs(data12$BP_A - data12$BP_B) / 1000
  # data12 <- data12[!data12$dist > opt$max, ]

  ## Remove marker pairs with complete linkage
  data12 <- subset(data12, !(R2_1 == 1 & R2_2 == 1))

  ## Overall correlation
  cors <- cor(data12$R2_1, data12$R2_2)
} else if (opt$bin_merge == "frq") {
  ## Calculate and unify relevant columns into "R2"
  names(data1)[5] <- names(data2)[5] <- "R2"

  data12 <- inner_join(data1, data2, by = c("CHR", "SNP"), suffix = c("_1", "_2"))

  trans <- data12$A1_1 == data12$A2_2 & data12$A2_1 == data12$A1_2
  matchs <-  data12$A1_1 == data12$A1_2 & data12$A2_1 == data12$A2_2
  if (sum(trans, matchs) != nrow(data12)) {
    cat("There are other types of conditions, please check (line91)\n")
    quit(status = 1)
  }

  ## Change allele and gene frequency
  data12$A1_2[trans] <- data12$A1_1[trans]
  data12$A2_2[trans] <- data12$A2_1[trans]
  data12$R2_2[trans] <- 1 - data12$R2_2[trans]

  ## Gene frequency correlation between breeds
  cors <- cor(data12$R2_1, data12$R2_2)
} else {
  cat("bin_merge can only be ld/frq!\n")
  quit(status = 1)
}

## Remove intermediate files
rm(data1, data2)

## Report overall correlation
cat("The overall correlation is:", cors, "\n")

## Function to merge adjacent regions and recalculate correlation
bins_merge <- function(stat_df, stat_bin, data_df, data_bin, seg = NULL) {
  # stat_df=bin_cor; stat_bin="bin_A"; data_df=data12_stat; data_bin="bin_A"; seg=opt$seg

  ## If seg is NULL, set it to 1 standard deviation of window correlation
  if (is.null(seg)) seg <- sd(stat_df$cor)

  i <- 1
  stat_df[["bin_temp"]] <- NA
  stat_df[["nsnp_new"]] <- NA
  while (i <= nrow(stat_df)) {
    s <- i
    e <- i
    hit <- FALSE
    while (!hit && i <= nrow(stat_df)) {
      if (i < nrow(stat_df)) {
        diff_cor <- abs(stat_df$cor[i] - stat_df$cor[i + 1]) >= seg
        diff_chr <- stat_df$CHR[i] != stat_df$CHR[i + 1]
      } else {
        diff_cor <- TRUE
        diff_chr <- TRUE
      }

      if (diff_cor || diff_chr) {
        e <- i
        hit <- TRUE
      }
      i <- i + 1
    }
    stat_df$bin_temp[s:e] <- stat_df[[stat_bin]][s]
    stat_df$nsnp_new[s:e] <- sum(stat_df$nsnp[s:e])
  }

  ## Recalculate correlation
  names(stat_df)[which(names(stat_df) == stat_bin)] <- data_bin
  bin_new <- stat_df[, c(data_bin, "bin_temp", "nsnp_new")]
  data_df <- left_join(data_df, bin_new, by = data_bin)
  stat_df <- dplyr::group_by(data_df, CHR, bin_temp) %>%
    dplyr::summarise(nsnp = mean(nsnp_new), start = min(BP_A, BP_B), end = max(BP_A, BP_B), cor = cor(R2_1, R2_2))

  ## Set correlation for zero standard deviation to correlation of adjacent markers
  sd0 <- which(is.na(stat_df$cor))
  stat_df$cor[sd0] <- stat_df$cor[sd0 - 1]

  names(stat_df)[2] <- data_bin

  ## Change region labels to consecutive integers
  stat_df[[data_bin]] <- as.numeric(as.factor(stat_df[[data_bin]]))

  return(stat_df)
}

## Preliminary division of regions
cat("Preliminary division based on ", opt$win, " SNPs in each bins...\n")
map$bin <- NA
map$nsnp <- NA
bin_start <- 1
for (i in seq_along(chrs)){
  ## Number of SNPs on the ith chromosome
  nsnp_i <- sum(map$CHR == chrs[i])

  ## Number of regions that can be divided based on opt$win
  win_num <- floor(nsnp_i / opt$win)

  ## If the number of markers on this chromosome is less than win, set win_num to 1
  if (win_num < 1) win_num <- 1 

  ## Number of SNPs in each region, the last region can exceed opt$win
  nsnp_bin <- rep(opt$win, win_num)
  nsnp_bin[win_num] <- nsnp_bin[win_num] + nsnp_i - sum(nsnp_bin)

  ## Region label for each SNP on chromosome i
  group <- rep(bin_start:(win_num + bin_start - 1), times = nsnp_bin)
  map$bin[map$CHR == chrs[i]] <- group[1:nsnp_i]

  ## Number of SNPs in each region
  nsnp_bin_map <- rep(nsnp_bin, times = nsnp_bin)
  map$nsnp[map$CHR == chrs[i]] <- nsnp_bin_map

  ## Record number of regions
  bin_start <- bin_start + win_num
}
cat("Number of bins before merging: ", max(map$bin), "\n")

## Match marker pairs in ld result file to bin regions
bins <- map[, c("CHR", "SNP", "POS", "bin", "nsnp")]
names(bins)[c(3, 4)] <- c("BP_A", "bin_A")
if (opt$bin_merge == "ld") {
  data12_bin <- inner_join(data12, bins, by = c("CHR", "BP_A"))
  bins <- bins[, -ncol(bins)]
  names(bins) <- c("CHR", "SNP", "BP_B", "bin_B")
  data12_bin <- inner_join(data12_bin, bins, by = c("CHR", "BP_B"))
  data12_stat <- subset(data12_bin, bin_A == bin_B)
} else {
  data12_stat <- inner_join(data12, bins, by = c("CHR", "SNP"), suffix = c("_1", "_2"))
  data12_stat$BP_B <- data12_stat$BP_A
}

## Calculate LD consistency within regions
bin_cor <- dplyr::group_by(data12_stat, CHR, bin_A) %>%
  dplyr::summarise(nsnp = mean(nsnp), start = min(BP_A, BP_B), end = max(BP_A, BP_B), cor = cor(R2_1, R2_2))

## Set correlation for zero standard deviation to correlation of adjacent markers
if (any((is.na(bin_cor$cor)))) {
  sd0 <- which(is.na(bin_cor$cor))
  for (i in sd0) {
    if (i > max(bin_cor$bin_A) %/% 2) {
      end <- max(bin_cor$bin_A)
    } else {
      end <- 1
    }

    for (j in i:end) {
      if (!is.na(bin_cor$cor[j])) {
        bin_cor$cor[sd0] <- bin_cor$cor[j]
        break
      }
    }
  }
}

cat("Merging adjacent windows based on threshold: ", opt$seg, "...\n")
## Merge adjacent windows based on a certain threshold
bin_cor <- bins_merge(bin_cor, "bin_A", data12_stat, "bin_A", opt$seg)

## Check if all chromosomes are included in bin_cor
miss_chr <- unique(map$CHR[!map$CHR %in% bin_cor$CHR])
if (length(miss_chr) > 0) {
  ## Add markers for missing chromosomes
  for (i in miss_chr) {
    add <- data.frame(CHR = i, bin_A = max(bin_cor$bin_A) + 1, nsnp = sum(map$CHR == i),
      start = min(map$POS[map$CHR == i]), end = max(map$POS[map$CHR == i]), cor = NA)
    bin_cor <- rbind(bin_cor, add)
  }
} 

## Check if the number of SNPs is consistent with the map file
if (snp_total != sum(bin_cor$nsnp)) {
  cat("Error! The number of snps in bins file is inconsistent with the map file.\n")
  cat("bins=", sum(bin_cor$nsnp), "≠", "map=", snp_total, "\n")
  quit(status = 1)
}

write.table(bin_cor, opt$out, col.names = FALSE, row.names = FALSE)
cat("File containing the number of SNPs in bins has been output to: ", opt$out, "\n")
cat("Number of bins after merging: ", nrow(bin_cor), "\n")
